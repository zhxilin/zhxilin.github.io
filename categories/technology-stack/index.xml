<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technology Stack on ZHXILIN&#39;S BLOG</title>
    <link>https://zhxilin.github.io/categories/technology-stack/</link>
    <description>Recent content in Technology Stack on ZHXILIN&#39;S BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016–2020, zhxilin&#39;s blog; all rights reserved.</copyright>
    <lastBuildDate>Wed, 11 May 2022 11:09:53 +0800</lastBuildDate>
    
	<atom:link href="https://zhxilin.github.io/categories/technology-stack/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>服务端技术栈知识体系</title>
      <link>https://zhxilin.github.io/post/tech_stack/summary/</link>
      <pubDate>Mon, 13 Dec 2021 10:36:27 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/summary/</guid>
      <description>&lt;p&gt;本人大学专业是软件工程（数字媒体技术），目前从事游戏服务端开发，在工作中也会经常面试候选人。结合大学计算机知识、工作经验和面试经历，本人总结了适合服务端开发的技术栈知识体系。&lt;/p&gt;
&lt;p&gt;本系列文章的特点是重点解析知识背后的原理，而不止是停留在使用层面。我认为知其然而不知其所以然是不可取的，我们要在学习实践的过程中搞懂每一个技术点背后的细节，才能称得上掌握了这项技术。本系列文章希望能帮助愿意在计算机编程领域挖掘背后原理的同学，同时也不断激励我继续深入学习。&lt;/p&gt;
&lt;p&gt;阅读本系列文章适合具备一定计算机编程基础的同学。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17 if/switch语句初始化</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/if_switch_init/</link>
      <pubDate>Wed, 11 May 2022 11:09:53 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/if_switch_init/</guid>
      <description>&lt;p&gt;C++17引入了&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;switch&lt;/code&gt;语句初始化的新特性，既解决了变量命名问题，也可使声明变量的作用域缩小。这一新特性还可以作用于&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/structured_bindings&#34;&gt;结构化绑定&lt;/a&gt;。本节内容主要介绍&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;switch&lt;/code&gt;语句初始化的使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17结构化绑定</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/structured_bindings/</link>
      <pubDate>Mon, 09 May 2022 11:25:31 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/structured_bindings/</guid>
      <description>&lt;p&gt;C++17提供了结构化绑定机制，可以使用指定名称绑定到初始化的子对象或元素上，与引用绑定别名类似，但结构化绑定的类型不需要是引用类型。得益于自动推导技术越来越成熟，通过&lt;code&gt;auto&lt;/code&gt;声明的多个变量绑定到一个复杂结构成了可能。本节内容我们来介绍C++17的新特性——结构化绑定。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17类模板参数推导</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/class_template_argument_deduction/</link>
      <pubDate>Sat, 07 May 2022 11:10:44 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/class_template_argument_deduction/</guid>
      <description>&lt;p&gt;在C++17之前，没有默认值的类模板参数总是需要显式将所有实参传递给类模板，而从C++17开始对于显示指定模板实参的限制已经取消。换言之，只要构造函数能推导出所有没有默认值的模板参数时，就可以省略模板实参的定义。本节内容将详细介绍C++17利用构造函数进行模板参数推导的过程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;14更多新特性</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/more_cpp14/</link>
      <pubDate>Fri, 06 May 2022 19:23:17 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/more_cpp14/</guid>
      <description>&lt;p&gt;C++14其实新增的特性不算太多，都是一些对C++11的一些优化和补充。大部分的新特性在前几篇文章&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/auto_enhanc&#34;&gt;《C++auto关键字改进》&lt;/a&gt;、&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/template_enhance&#34;&gt;《C++14模板的改进》&lt;/a&gt;、&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/read_write_lock&#34;&gt;《C++读写锁》&lt;/a&gt;、&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/exchange&#34;&gt;《C++14 exchange》&lt;/a&gt;中都有介绍，剩下的新特性在这篇文章中集中介绍。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;14 exchange</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/exchange/</link>
      <pubDate>Fri, 06 May 2022 15:18:41 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/exchange/</guid>
      <description>&lt;p&gt;C++14开始新增了&lt;code&gt;std::exchange&lt;/code&gt;函数，基于移动语义对资源进行转移，省去了拷贝的消耗。新增的这个函数名表面上看起来是“交换”，但实际上并不是两者进行交换，而是将后者转移给前者，后者没有变化。本节内容介绍&lt;code&gt;std::exchange&lt;/code&gt;和&lt;code&gt;std::swap&lt;/code&gt;实现上的区别。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;读写锁</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/read_write_lock/</link>
      <pubDate>Thu, 05 May 2022 14:33:59 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/read_write_lock/</guid>
      <description>&lt;p&gt;读写锁是并发编程中的一项重要的技术，相较于互斥锁（要么锁住要么不加锁），读写锁可以在更细的粒度上提高并发性能。现代C++提供了&lt;code&gt;std::shared_mutex&lt;/code&gt;和&lt;code&gt;std::shared_timed_mutex&lt;/code&gt;两种共享互斥量，以及用来管理这类共享互斥量的&lt;code&gt;std::shared_lock&lt;/code&gt;。本节内容对现代C++中的读写锁进行详细介绍。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;14模板的改进</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/template_enhance/</link>
      <pubDate>Thu, 05 May 2022 10:22:44 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/template_enhance/</guid>
      <description>&lt;p&gt;C++14引入了变量模板的新形式，在语法上等价于一个没有参数但是有返回值的模板函数。变量模板在语法上更加清晰简便，仅仅是一个语法糖。本节内容就介绍一下变量模板特性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;14 auto关键字的改进</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/auto_enhance/</link>
      <pubDate>Mon, 02 May 2022 16:17:28 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/auto_enhance/</guid>
      <description>&lt;p&gt;C++11对&lt;code&gt;auto&lt;/code&gt;关键字进行了重新定义，到了C++14又对&lt;code&gt;auto&lt;/code&gt;关键字做了进一步的改进。从&lt;code&gt;C++14&lt;/code&gt;开始，&lt;code&gt;auto&lt;/code&gt;关键字可以用于函数返回值推导和lambda表达式参数列表的类型推导了。本节内容就围绕这两项改进详细展开。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>STL std::sort是什么样的排序？</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/sort/</link>
      <pubDate>Fri, 29 Apr 2022 16:19:14 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/sort/</guid>
      <description>&lt;p&gt;排序是最基础的一种算法，C++的STL标准库也提供了一些关于排序算法的实现，其中使用最多的当属&lt;code&gt;std::sort()&lt;/code&gt;了，也是工作面试中的高频主角。本节内容将对&lt;code&gt;std::sort()&lt;/code&gt;具体的源码实现进行详细解剖。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL标准库概览</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/stl/</link>
      <pubDate>Thu, 28 Apr 2022 19:01:49 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/stl/</guid>
      <description>&lt;p&gt;STL的核心是三大组件：容器、迭代器和算法。本文通过一个概览图展示一下整个STL三大组件的逻辑关系。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;列表初始化</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/list_initialization/</link>
      <pubDate>Thu, 28 Apr 2022 15:05:41 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/list_initialization/</guid>
      <description>&lt;p&gt;在传统C++中，只能对普通数组和&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/pod&#34;&gt;POD类型&lt;/a&gt;使用列表初始化，适用范围非常有限。在现代C++中，统一了初始化方式，任何类型对象的初始化都可以使用列表初始化了。本节内容我们讲解列表初始化的各项使用细节。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; auto关键字</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/auto/</link>
      <pubDate>Thu, 28 Apr 2022 10:42:51 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/auto/</guid>
      <description>&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;关键字在C++11中进行了重新定义，抛弃了传统C++中&lt;code&gt;auto&lt;/code&gt;是用来自动延长对象生命周期的用法，而是将其用作类型自动推导。本节内容主要讨论&lt;code&gt;auto&lt;/code&gt;的用法以及一些注意事项。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;用户定义字面量</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/user_defined_literal/</link>
      <pubDate>Wed, 27 Apr 2022 17:09:25 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/user_defined_literal/</guid>
      <description>&lt;p&gt;C++11引入了用户自定义字面量（user-defined literal），也叫自定义后缀操作符。通过实现一个后缀操作符，可以将声明了后缀标识的字面量转换为所需的类型和数值。本节内容我们将探讨各种常见的字面量，以及C++11新加入的用户定义字面量。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;原始字符串字面量</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/raw_string_literal/</link>
      <pubDate>Wed, 27 Apr 2022 14:53:46 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/raw_string_literal/</guid>
      <description>&lt;p&gt;在传统C++中，字符串字面量的语法对一些特殊字符并不友好，需要通过转义字符来表示这些特殊字符。这对简单字符串计算量并不大，但在一些特殊情况如正则表达式中，可读性和性能就会非常差。因此C++11引入了原始字符串字面量（raw string literal）来解决字符串的表达形式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;类内初始化</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/in-class_initialization/</link>
      <pubDate>Wed, 27 Apr 2022 10:22:58 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/in-class_initialization/</guid>
      <description>&lt;p&gt;现代C++提供了3种对类成员的初始化方式，即构造函数初始化、初始化列表，以及C++11新加入的类内初始化。本节内容将具体讲解这3种类成员初始化方式的用法，并比较他们之间的区别。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;闭包</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/closure/</link>
      <pubDate>Tue, 26 Apr 2022 12:02:34 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/closure/</guid>
      <description>&lt;p&gt;闭包，closure，一般是指带有状态的函数，这里的状态指的是调用环境的上下文。一个函数带上了状态，就是闭包。那么闭包就需要有捕获并持有外部作用域变量的能力，闭包状态的捆绑发生在运行时。在C++中，闭包的实现方式包括仿函数、&lt;code&gt;std::bind()&lt;/code&gt;绑定器以及lambda表达式。仿函数在以前的文章&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/functor&#34;&gt;《C++仿函数》&lt;/a&gt;中以前介绍过了，本文将重点讨论另外两种闭包实现类型的用法和原理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;复制消除与RVO/NRVO</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/rvo_nrvo/</link>
      <pubDate>Mon, 25 Apr 2022 10:47:59 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/rvo_nrvo/</guid>
      <description>&lt;p&gt;C++11标准明确提出了复制消除（copy elision）优化技术，复制消除要求编译器在满足一些特定条件时，省略类对象的拷贝和移动构造，以达到优化效果。复制消除主要发生在两种条件下，即函数参数是值语义以及函数返回值是值语义。而RVO和NRVO是函数返回值优化的两种技术，NRVO从C++11开始加入C++标准。&lt;/p&gt;
&lt;p&gt;本文我们将讨论的主题围绕函数返回值优化，先了解RVO和NRVO在不同的现代C++版本中，启用和关闭编译器优化之后各自的表现；接着我们将分析RVO和NRVO的实现原理；最后聊一下优化失效的情形。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;引用包装</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/reference_wrapper/</link>
      <pubDate>Sun, 24 Apr 2022 19:32:40 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/reference_wrapper/</guid>
      <description>&lt;p&gt;现代C++引入一个&lt;code&gt;std::ref()&lt;/code&gt;用来模拟某个变量的引用。C++原来就有引用，为什么还需要模拟引用呢？这是为了解决某些场景下，只能值传递传参，却需要对传入的参数进行修改的问题。这类问题往往出现在函数式编程里。&lt;/p&gt;
&lt;p&gt;理解&lt;code&gt;std::ref()&lt;/code&gt;之前还需要先了解一个引用包装（reference wrapper）的概念，&lt;code&gt;std::ref()&lt;/code&gt;的返回值就是一个引用包装。&lt;/p&gt;
&lt;p&gt;本文围绕&lt;code&gt;&amp;lt;refwrap&amp;gt;&lt;/code&gt;头文件提供的&lt;code&gt;std::reference_wrapper&lt;/code&gt;和&lt;code&gt;std::ref&lt;/code&gt;的实现细节，来说明为什么需要这项技术。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;移动语义、万能引用、引用折叠、完美转发</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/move_forward/</link>
      <pubDate>Fri, 22 Apr 2022 19:10:23 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/move_forward/</guid>
      <description>&lt;p&gt;现代C++提供了移动语义相关的操作，通过移动语义可以将资源的所有权转移到新的对象上，从而避免数据拷贝带来的性能开销。移动语义实现了从一个对象到另一个对象的资源转移的过程。标准库为移动语义提供了辅助函数&lt;code&gt;std::move()&lt;/code&gt;，用于执行一个无条件的对&lt;code&gt;rvalue&lt;/code&gt;的转换，对于函数本身而言，并不移动任何内容，只是强制转化左值引用为右值引用，从而通过这个右值引用使用该值，以用于移动语义。与之类似的还有一个辅助函数&lt;code&gt;std::forward()&lt;/code&gt;，它和&lt;code&gt;std::move()&lt;/code&gt;类似，但只有在参数被一个&lt;code&gt;lvalue&lt;/code&gt;初始化时，才会转换为&lt;code&gt;rvalue&lt;/code&gt;。&lt;code&gt;std::forward()&lt;/code&gt;还能将一组参数原封不动地传递给另一个函数，包括参数的属性（左值/右值和&lt;code&gt;const&lt;/code&gt;/非&lt;code&gt;const&lt;/code&gt;），这个过程叫完美转发。&lt;/p&gt;
&lt;p&gt;提到移动语义和完美转发，就不得不谈及&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/lvalue_rvalue&#34;&gt;右值引用&lt;/a&gt;。右值引用的基本形式是&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;，这需要和模板编程中的万能引用&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;有所区别。在模板编程中，当传递不同属性的参数到&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;中时进行的类型推导需要遵循引用折叠原则。&lt;/p&gt;
&lt;p&gt;本节内容将就移动语义、万能引用、引用折叠和完美转发一一展开。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; NULL与nullptr</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/null_nullptr/</link>
      <pubDate>Fri, 22 Apr 2022 15:59:11 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/null_nullptr/</guid>
      <description>&lt;p&gt;在C语言中，我们使用&lt;code&gt;NULL&lt;/code&gt;来代表一个空指针，而这种做法在现代C++是不允许的。在现代C++中，&lt;code&gt;NULL&lt;/code&gt;本质上是一个类型为&lt;code&gt;long int&lt;/code&gt;的数值&lt;code&gt;0&lt;/code&gt;，而空指针需要用C++11新引入的&lt;code&gt;nullptr&lt;/code&gt;来表示。&lt;/p&gt;
&lt;p&gt;那么在现代C++中，&lt;code&gt;NULL&lt;/code&gt;和&lt;code&gt;nullptr&lt;/code&gt;使用上有什么区别？为什么会有&lt;code&gt;nullptr&lt;/code&gt;？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/smart_pointer/</link>
      <pubDate>Tue, 19 Apr 2022 17:28:10 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/smart_pointer/</guid>
      <description>&lt;p&gt;在传统C++中，我们一般使用&lt;code&gt;new/delete&lt;/code&gt;或&lt;code&gt;malloc/free&lt;/code&gt;等方式来管理内存，但是由于申请内存和释放内存的过程都需要开发者自己维护，而只要是需要手动管理的逻辑，就有可能出现忘记释放或者多次释放内存的错误，这也是传统C++一致为人诟病的一个问题。在现代C++中，标准库提供了智能指针的实现，这些指针用于帮助确保程序不会出现内存和资源泄露，并具有异常安全。可以说现代C++的智能指针使得内存管理更加方便更加安全。本节内容我们将解析各类智能指针的底层实现原理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存对齐</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/memory_alignment/</link>
      <pubDate>Mon, 18 Apr 2022 11:55:22 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/memory_alignment/</guid>
      <description>&lt;p&gt;现代计算机的处理器为了高效地处理数据的存取，会以内存存取粒度为单位进行。为了让数据在内容中能够以内存存取粒度为单位进行排列，就需要内存对齐技术。本节内容将介绍内存对齐的意义和内存对齐规则。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;位域</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/bit_field/</link>
      <pubDate>Fri, 15 Apr 2022 21:22:55 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/bit_field/</guid>
      <description>&lt;p&gt;位域是一种特殊的数据结构，可以节省内存资源，使数据结构的存储更加紧凑。本节内容将全面了解一下位域的方方面面。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; RTTI与反射</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/rtti_reflection/</link>
      <pubDate>Fri, 15 Apr 2022 10:33:39 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/rtti_reflection/</guid>
      <description>&lt;p&gt;前文&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_c++/language_base/object_memory_layout&#34;&gt;《对象内存模型》&lt;/a&gt;在介绍C++对象内存模型中有提到过&lt;code&gt;type_info&lt;/code&gt;对象。&lt;code&gt;type_info&lt;/code&gt;是RTTI机制的核心内容。那什么是RTTI？反射和RTTI又有什么关系？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;对象内存模型</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/object_memory_layout/</link>
      <pubDate>Tue, 12 Apr 2022 17:23:56 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/object_memory_layout/</guid>
      <description>&lt;p&gt;C++的三大特性是封装、继承和多态，而要理解这些特性的底层原理，就不得不说说C++对象的内存模型（布局）。&lt;/p&gt;
&lt;p&gt;对于一个C++对象，每个对象有独立的非静态数据成员，而内存中只有一份成员函数，所有该类的对象共享成员函数；&lt;code&gt;static&lt;/code&gt;数据成员属于类，它们存储在静态存储区，该类的所有对象共享。当调用对象的成员函数时，又是怎么识别是哪个对象在调用呢？实际上，所有类的成员函数在编译期会被编译器重构成非成员函数，即将&lt;code&gt;this&lt;/code&gt;指针作为函数的第一个参数，这样在函数中通过&lt;code&gt;this&lt;/code&gt;指针就能找到属于该对象的其他数据成员了。这些都是理解C++对象内存模型的前提。&lt;/p&gt;
&lt;p&gt;当出现了类的继承关系，且存在虚函数的时候，情况就复杂了。本节内容将详细介绍单一继承、多重继承、重复继承、虚拟继承等不同的继承方式的对象内存模型。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; extern关键字</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/extern/</link>
      <pubDate>Tue, 12 Apr 2022 14:21:09 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/extern/</guid>
      <description>&lt;p&gt;在C++标准库中，我们经常可以看到&lt;code&gt;extern&lt;/code&gt;关键字的使用。围绕声明与定义、&lt;code&gt;extern&lt;/code&gt;和&lt;code&gt;static&lt;/code&gt;、&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;，本节内容将尝试一次性讲清楚。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; volatile的作用</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/volatile/</link>
      <pubDate>Tue, 12 Apr 2022 10:19:28 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/volatile/</guid>
      <description>&lt;p&gt;C++中&lt;code&gt;volatile&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;对应，都是用来修饰变量的关键字。&lt;code&gt;volatile&lt;/code&gt;关键字通常用来建立语言级别的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C&#34;&gt;内存屏障（memory barrier）&lt;/a&gt;。为什么要使用&lt;code&gt;volatile&lt;/code&gt;？&lt;code&gt;volatile&lt;/code&gt;关键字的含义是什么？&lt;code&gt;volatile&lt;/code&gt;与多线程有什么关系？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;左值&amp;右值，左值引用&amp;右值引用</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/lvalue_rvalue/</link>
      <pubDate>Mon, 11 Apr 2022 16:22:51 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/lvalue_rvalue/</guid>
      <description>&lt;p&gt;C++11引入了右值引用的概念，用以区分C++11之前的引用（统称左值引用）。那么什么是右值引用？右值又是什么？和左值、左值引用有什么关系和区别？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; new表达式、operator new和placement new</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/new/</link>
      <pubDate>Mon, 11 Apr 2022 11:38:45 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/new/</guid>
      <description>&lt;p&gt;C++中&lt;code&gt;new&lt;/code&gt;关键字和&lt;code&gt;delete&lt;/code&gt;关键字我们肯定都使用过，它们是对堆中的内存进行申请和释放的操作，这两个操作是不能被重载的。有的同学可能会被问到，如何实现自定义内存分配行为。搞懂这个问题之前，我们需要先了解&lt;code&gt;new&lt;/code&gt;表达式、&lt;code&gt;operator new&lt;/code&gt;和&lt;code&gt;placement new&lt;/code&gt;之间的关系。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;仿函数</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/functor/</link>
      <pubDate>Sun, 10 Apr 2022 15:21:51 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/functor/</guid>
      <description>&lt;p&gt;C++中仿函数是一个能行使函数功能的类，仿函数的使用方法几乎和函数一样。那么仿函数和函数到底有什么区别？仿函数有哪些优点？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;类型转换</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/type_cast/</link>
      <pubDate>Sun, 10 Apr 2022 11:28:51 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/type_cast/</guid>
      <description>&lt;p&gt;C++的类型转换分为隐式转换和显式转换。数值之间如何转换、指针之间如何转换、explicit关键字又是什么、强制类型转换操作符的区别又是什么，本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;引用、指针、迭代器的区别？</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/reference_pointer_iterator/</link>
      <pubDate>Sun, 10 Apr 2022 10:26:35 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/reference_pointer_iterator/</guid>
      <description>&lt;p&gt;引用与指针的异同、指针与迭代器的异同，是一个老生常谈的话题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 什么是POD?</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/pod/</link>
      <pubDate>Sat, 09 Apr 2022 17:50:42 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/pod/</guid>
      <description>&lt;p&gt;为了兼容C内存的数据类型，C++11提出了POD的概念。什么是POD类型，POD类型有什么作用，本节内容将一一揭晓。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>应用技术</title>
      <link>https://zhxilin.github.io/post/tech_stack/9_application_technology/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:05:07 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/9_application_technology/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>软件工程</title>
      <link>https://zhxilin.github.io/post/tech_stack/8_software_engeering/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:04:53 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/8_software_engeering/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>分布式架构</title>
      <link>https://zhxilin.github.io/post/tech_stack/7_distributed_architecture/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:04:35 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/7_distributed_architecture/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>编译原理</title>
      <link>https://zhxilin.github.io/post/tech_stack/6_compile_principle/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:03:58 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/6_compile_principle/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数据库</title>
      <link>https://zhxilin.github.io/post/tech_stack/5_database/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:03:44 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/5_database/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>网络</title>
      <link>https://zhxilin.github.io/post/tech_stack/4_networks/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:03:37 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/4_networks/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://zhxilin.github.io/post/tech_stack/3_os/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:03:21 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/3_os/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数据结构与算法</title>
      <link>https://zhxilin.github.io/post/tech_stack/2_ds_algorithm/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:02:52 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/2_ds_algorithm/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>编程语言</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/summary/</link>
      <pubDate>Fri, 08 Apr 2022 19:52:39 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/summary/</guid>
      <description>&lt;p&gt;编程语言，是计算机科学的基础学科。C++作为一门历史悠久的常青树语言，也在不断与时俱进，注入新的活动，依然是当今最流行最稳定的编程语言之一。&lt;/p&gt;
&lt;p&gt;本章节将重点围绕现代C++、C++并发编程以及C++模板编程等方面展开。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>