<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>现代C&#43;&#43; on ZHXILIN&#39;S BLOG</title>
    <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/</link>
    <description>Recent content in 现代C&#43;&#43; on ZHXILIN&#39;S BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016–2020, zhxilin&#39;s blog; all rights reserved.</copyright>
    <lastBuildDate>Sun, 10 Apr 2022 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C&#43;&#43;复制消除与RVO/NRVO</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/rvo_nrvo/</link>
      <pubDate>Mon, 25 Apr 2022 10:47:59 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/rvo_nrvo/</guid>
      <description>&lt;p&gt;C++11标准明确提出了复制消除（copy elision）优化技术，复制消除要求编译器在满足一些特定条件时，省略类对象的拷贝和移动构造，以达到优化效果。复制消除主要发生在两种条件下，即函数参数是值语义以及函数返回值是值语义。而RVO和NRVO是函数返回值优化的两种技术，NRVO从C++11开始加入C++标准。&lt;/p&gt;
&lt;p&gt;本文我们将讨论的主题围绕函数返回值优化，先了解RVO和NRVO在不同的现代C++版本中，启用和关闭编译器优化之后各自的表现；接着我们将分析RVO和NRVO的实现原理；最后聊一下优化失效的情形。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;引用包装</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/reference_wrapper/</link>
      <pubDate>Sun, 24 Apr 2022 19:32:40 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/reference_wrapper/</guid>
      <description>&lt;p&gt;现代C++引入一个&lt;code&gt;std::ref()&lt;/code&gt;用来模拟某个变量的引用。C++原来就有引用，为什么还需要模拟引用呢？这是为了解决某些场景下，只能值传递传参，却需要对传入的参数进行修改的问题。这类问题往往出现在函数式编程里。&lt;/p&gt;
&lt;p&gt;理解&lt;code&gt;std::ref()&lt;/code&gt;之前还需要先了解一个引用包装（reference wrapper）的概念，&lt;code&gt;std::ref()&lt;/code&gt;的返回值就是一个引用包装。&lt;/p&gt;
&lt;p&gt;本文围绕&lt;code&gt;&amp;lt;refwrap&amp;gt;&lt;/code&gt;头文件提供的&lt;code&gt;std::reference_wrapper&lt;/code&gt;和&lt;code&gt;std::ref&lt;/code&gt;的实现细节，来说明为什么需要这项技术。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;移动语义、万能引用、引用折叠、完美转发</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/move_forward/</link>
      <pubDate>Fri, 22 Apr 2022 19:10:23 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/move_forward/</guid>
      <description>&lt;p&gt;现代C++提供了移动语义相关的操作，通过移动语义可以将资源的所有权转移到新的对象上，从而避免数据拷贝带来的性能开销。移动语义实现了从一个对象到另一个对象的资源转移的过程。标准库为移动语义提供了辅助函数&lt;code&gt;std::move()&lt;/code&gt;，用于执行一个无条件的对&lt;code&gt;rvalue&lt;/code&gt;的转换，对于函数本身而言，并不移动任何内容，只是强制转化左值引用为右值引用，从而通过这个右值引用使用该值，以用于移动语义。与之类似的还有一个辅助函数&lt;code&gt;std::forward()&lt;/code&gt;，它和&lt;code&gt;std::move()&lt;/code&gt;类似，但只有在参数被一个&lt;code&gt;lvalue&lt;/code&gt;初始化时，才会转换为&lt;code&gt;rvalue&lt;/code&gt;。&lt;code&gt;std::forward()&lt;/code&gt;还能将一组参数原封不动地传递给另一个函数，包括参数的属性（左值/右值和&lt;code&gt;const&lt;/code&gt;/非&lt;code&gt;const&lt;/code&gt;），这个过程叫完美转发。&lt;/p&gt;
&lt;p&gt;提到移动语义和完美转发，就不得不谈及&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/lvalue_rvalue&#34;&gt;右值引用&lt;/a&gt;。右值引用的基本形式是&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;，这需要和模板编程中的万能引用&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;有所区别。在模板编程中，当传递不同属性的参数到&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;中时进行的类型推导需要遵循引用折叠原则。&lt;/p&gt;
&lt;p&gt;本节内容将就移动语义、万能引用、引用折叠和完美转发一一展开。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; NULL与nullptr</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/null_nullptr/</link>
      <pubDate>Fri, 22 Apr 2022 15:59:11 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/null_nullptr/</guid>
      <description>&lt;p&gt;在C语言中，我们使用&lt;code&gt;NULL&lt;/code&gt;来代表一个空指针，而这种做法在现代C++是不允许的。在现代C++中，&lt;code&gt;NULL&lt;/code&gt;本质上是一个类型为&lt;code&gt;long int&lt;/code&gt;的数值&lt;code&gt;0&lt;/code&gt;，而空指针需要用C++11新引入的&lt;code&gt;nullptr&lt;/code&gt;来表示。&lt;/p&gt;
&lt;p&gt;那么在现代C++中，&lt;code&gt;NULL&lt;/code&gt;和&lt;code&gt;nullptr&lt;/code&gt;使用上有什么区别？为什么会有&lt;code&gt;nullptr&lt;/code&gt;？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/smart_pointer/</link>
      <pubDate>Tue, 19 Apr 2022 17:28:10 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/smart_pointer/</guid>
      <description>&lt;p&gt;在传统C++中，我们一般使用&lt;code&gt;new/delete&lt;/code&gt;或&lt;code&gt;malloc/free&lt;/code&gt;等方式来管理内存，但是由于申请内存和释放内存的过程都需要开发者自己维护，而只要是需要手动管理的逻辑，就有可能出现忘记释放或者多次释放内存的错误，这也是传统C++一致为人诟病的一个问题。在现代C++中，标准库提供了智能指针的实现，这些指针用于帮助确保程序不会出现内存和资源泄露，并具有异常安全。可以说现代C++的智能指针使得内存管理更加方便更加安全。本节内容我们将解析各类智能指针的底层实现原理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存对齐</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/memory_alignment/</link>
      <pubDate>Mon, 18 Apr 2022 11:55:22 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/memory_alignment/</guid>
      <description>&lt;p&gt;现代计算机的处理器为了高效地处理数据的存取，会以内存存取粒度为单位进行。为了让数据在内容中能够以内存存取粒度为单位进行排列，就需要内存对齐技术。本节内容将介绍内存对齐的意义和内存对齐规则。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;位域</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/bit_field/</link>
      <pubDate>Fri, 15 Apr 2022 21:22:55 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/bit_field/</guid>
      <description>&lt;p&gt;位域是一种特殊的数据结构，可以节省内存资源，使数据结构的存储更加紧凑。本节内容将全面了解一下位域的方方面面。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; RTTI与反射</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/rtti_reflection/</link>
      <pubDate>Fri, 15 Apr 2022 10:33:39 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/rtti_reflection/</guid>
      <description>&lt;p&gt;前文&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_c++/language_base/object_memory_layout&#34;&gt;《对象内存模型》&lt;/a&gt;在介绍C++对象内存模型中有提到过&lt;code&gt;type_info&lt;/code&gt;对象。&lt;code&gt;type_info&lt;/code&gt;是RTTI机制的核心内容。那什么是RTTI？反射和RTTI又有什么关系？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;对象内存模型</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/object_memory_layout/</link>
      <pubDate>Tue, 12 Apr 2022 17:23:56 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/object_memory_layout/</guid>
      <description>&lt;p&gt;C++的三大特性是封装、继承和多态，而要理解这些特性的底层原理，就不得不说说C++对象的内存模型（布局）。&lt;/p&gt;
&lt;p&gt;对于一个C++对象，每个对象有独立的非静态数据成员，而内存中只有一份成员函数，所有该类的对象共享成员函数；&lt;code&gt;static&lt;/code&gt;数据成员属于类，它们存储在静态存储区，该类的所有对象共享。当调用对象的成员函数时，又是怎么识别是哪个对象在调用呢？实际上，所有类的成员函数在编译期会被编译器重构成非成员函数，即将&lt;code&gt;this&lt;/code&gt;指针作为函数的第一个参数，这样在函数中通过&lt;code&gt;this&lt;/code&gt;指针就能找到属于该对象的其他数据成员了。这些都是理解C++对象内存模型的前提。&lt;/p&gt;
&lt;p&gt;当出现了类的继承关系，且存在虚函数的时候，情况就复杂了。本节内容将详细介绍单一继承、多重继承、重复继承、虚拟继承等不同的继承方式的对象内存模型。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; extern关键字</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/extern/</link>
      <pubDate>Tue, 12 Apr 2022 14:21:09 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/extern/</guid>
      <description>&lt;p&gt;在C++标准库中，我们经常可以看到&lt;code&gt;extern&lt;/code&gt;关键字的使用。围绕声明与定义、&lt;code&gt;extern&lt;/code&gt;和&lt;code&gt;static&lt;/code&gt;、&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;，本节内容将尝试一次性讲清楚。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; volatile的作用</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/volatile/</link>
      <pubDate>Tue, 12 Apr 2022 10:19:28 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/volatile/</guid>
      <description>&lt;p&gt;C++中&lt;code&gt;volatile&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;对应，都是用来修饰变量的关键字。&lt;code&gt;volatile&lt;/code&gt;关键字通常用来建立语言级别的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C&#34;&gt;内存屏障（memory barrier）&lt;/a&gt;。为什么要使用&lt;code&gt;volatile&lt;/code&gt;？&lt;code&gt;volatile&lt;/code&gt;关键字的含义是什么？&lt;code&gt;volatile&lt;/code&gt;与多线程有什么关系？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;左值&amp;右值，左值引用&amp;右值引用</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/lvalue_rvalue/</link>
      <pubDate>Mon, 11 Apr 2022 16:22:51 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/lvalue_rvalue/</guid>
      <description>&lt;p&gt;C++11引入了右值引用的概念，用以区分C++11之前的引用（统称左值引用）。那么什么是右值引用？右值又是什么？和左值、左值引用有什么关系和区别？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; new表达式、operator new和placement new</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/new/</link>
      <pubDate>Mon, 11 Apr 2022 11:38:45 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/new/</guid>
      <description>&lt;p&gt;C++中&lt;code&gt;new&lt;/code&gt;关键字和&lt;code&gt;delete&lt;/code&gt;关键字我们肯定都使用过，它们是对堆中的内存进行申请和释放的操作，这两个操作是不能被重载的。有的同学可能会被问到，如何实现自定义内存分配行为。搞懂这个问题之前，我们需要先了解&lt;code&gt;new&lt;/code&gt;表达式、&lt;code&gt;operator new&lt;/code&gt;和&lt;code&gt;placement new&lt;/code&gt;之间的关系。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;仿函数</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/functor/</link>
      <pubDate>Sun, 10 Apr 2022 15:21:51 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/functor/</guid>
      <description>&lt;p&gt;C++中仿函数是一个能行使函数功能的类，仿函数的使用方法几乎和函数一样。那么仿函数和函数到底有什么区别？仿函数有哪些优点？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;类型转换</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/type_cast/</link>
      <pubDate>Sun, 10 Apr 2022 11:28:51 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/type_cast/</guid>
      <description>&lt;p&gt;C++的类型转换分为隐式转换和显式转换。数值之间如何转换、指针之间如何转换、explicit关键字又是什么、强制类型转换操作符的区别又是什么，本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;引用、指针、迭代器的区别？</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/reference_pointer_iterator/</link>
      <pubDate>Sun, 10 Apr 2022 10:26:35 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/reference_pointer_iterator/</guid>
      <description>&lt;p&gt;引用与指针的异同、指针与迭代器的异同，是一个老生常谈的话题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 什么是POD?</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/pod/</link>
      <pubDate>Sat, 09 Apr 2022 17:50:42 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/pod/</guid>
      <description>&lt;p&gt;为了兼容C内存的数据类型，C++11提出了POD的概念。什么是POD类型，POD类型有什么作用，本节内容将一一揭晓。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>