<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ZHXILIN&#39;S BLOG</title>
    <link>https://zhxilin.github.io/</link>
    <description>Recent content on ZHXILIN&#39;S BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016–2020, zhxilin&#39;s blog; all rights reserved.</copyright>
    <lastBuildDate>Tue, 31 May 2022 15:58:59 +0800</lastBuildDate>
    
	<atom:link href="https://zhxilin.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>服务端技术栈知识体系</title>
      <link>https://zhxilin.github.io/post/tech_stack/summary/</link>
      <pubDate>Mon, 13 Dec 2021 10:36:27 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/summary/</guid>
      <description>&lt;p&gt;本人大学专业是软件工程（数字媒体技术），目前从事游戏服务端开发，在工作中也会经常面试候选人。结合大学计算机知识、工作经验和面试经历，本人总结了适合服务端开发的技术栈知识体系。&lt;/p&gt;
&lt;p&gt;本系列文章的特点是重点解析知识背后的原理，而不止是停留在使用层面。我认为知其然而不知其所以然是不可取的，我们要在学习实践的过程中搞懂每一个技术点背后的细节，才能称得上掌握了这项技术。本系列文章希望能帮助愿意在计算机编程领域挖掘背后原理的同学，同时也不断激励我继续深入学习。&lt;/p&gt;
&lt;p&gt;阅读本系列文章适合具备一定计算机编程基础的同学。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17更多新特性</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/more_cpp17/</link>
      <pubDate>Tue, 31 May 2022 15:58:59 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/more_cpp17/</guid>
      <description>&lt;p&gt;C++17新增了不少新特性，重点部分我们在前几篇文章&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/class_template_argument_deduction&#34;&gt;《C++17类模板参数推导》&lt;/a&gt;、&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/structured_bindings&#34;&gt;《C++17结构化绑定》&lt;/a&gt;、&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/if_switch_init&#34;&gt;《C++17 if-switch语句初始化》&lt;/a&gt;、&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/fold_expressions&#34;&gt;《C++17折叠表达式》&lt;/a&gt;、&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/string_view&#34;&gt;《C++17 string_view》&lt;/a&gt;、&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/constexpr&#34;&gt;《C++17 constexpr的改进》&lt;/a&gt;中都有介绍，剩下的新特性在这篇文章中集中介绍。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17 constexpr的改进</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/constexpr/</link>
      <pubDate>Mon, 23 May 2022 18:48:09 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/constexpr/</guid>
      <description>&lt;p&gt;C++17的&lt;code&gt;constexpr&lt;/code&gt;扩展了使用范畴，lambda表达式被纳入了&lt;code&gt;constexpr&lt;/code&gt;的表达范畴，弥补了C++17之前无法使用&lt;code&gt;constexpr&lt;/code&gt; lambda的遗憾，我们可以在只接受编译器常量的地方调用lambda表达式定义的lambda函数了。另外还提供了&lt;code&gt;constexpr if&lt;/code&gt;语法的支持，可以在编译期进行逻辑判定，提供编译效率。本节内容通过回顾C++11和C++14标准定义的&lt;code&gt;constexpr&lt;/code&gt;，然后展开介绍C++17对此的改进。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17 string_view的原理</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/string_view/</link>
      <pubDate>Tue, 17 May 2022 14:46:00 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/string_view/</guid>
      <description>&lt;p&gt;字符串操作是我们日常开发过程中最常见的一环。在C++中，我们会经常结合C风格字符串（字符串字面值、字符数组、字符串指针）、&lt;code&gt;std::string&lt;/code&gt;等方式来传递。而这些常见手段总会面临需要进行数据拷贝或者其他较为耗时的操作。C++17引入了&lt;code&gt;std::string_view&lt;/code&gt;来解决这些问题，非常类似于Golang中的切片。本节内容就着重介绍&lt;code&gt;std::string_view&lt;/code&gt;的原理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17折叠表达式</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/fold_expressions/</link>
      <pubDate>Wed, 11 May 2022 15:31:35 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/fold_expressions/</guid>
      <description>&lt;p&gt;C++11引入了可变参数模板（variadic template），它可以接收任意数量的模板参数，但是参数包不能直接展开，需要通过递归或者逗号表达式的方式进行展开，写法非常繁琐。C++17对这个问题进行了优化，引入了折叠表达式的概念，用来简化对可变参数模板中参数包的展开过程。本节内容重点介绍折叠表达式的使用方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17 if/switch语句初始化</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/if_switch_init/</link>
      <pubDate>Wed, 11 May 2022 11:09:53 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/if_switch_init/</guid>
      <description>&lt;p&gt;C++17引入了&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;switch&lt;/code&gt;语句初始化的新特性，既解决了变量命名问题，也可使声明变量的作用域缩小。这一新特性还可以作用于&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/structured_bindings&#34;&gt;结构化绑定&lt;/a&gt;。本节内容主要介绍&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;switch&lt;/code&gt;语句初始化的使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17结构化绑定</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/structured_bindings/</link>
      <pubDate>Mon, 09 May 2022 11:25:31 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/structured_bindings/</guid>
      <description>&lt;p&gt;C++17提供了结构化绑定机制，可以使用指定名称绑定到初始化的子对象或元素上，与引用绑定别名类似，但结构化绑定的类型不需要是引用类型。得益于自动推导技术越来越成熟，通过&lt;code&gt;auto&lt;/code&gt;声明的多个变量绑定到一个复杂结构成了可能。本节内容我们来介绍C++17的新特性——结构化绑定。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;17类模板参数推导</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/class_template_argument_deduction/</link>
      <pubDate>Sat, 07 May 2022 11:10:44 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/class_template_argument_deduction/</guid>
      <description>&lt;p&gt;在C++17之前，没有默认值的类模板参数总是需要显式将所有实参传递给类模板，而从C++17开始对于显示指定模板实参的限制已经取消。换言之，只要构造函数能推导出所有没有默认值的模板参数时，就可以省略模板实参的定义。本节内容将详细介绍C++17利用构造函数进行模板参数推导的过程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;14更多新特性</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/more_cpp14/</link>
      <pubDate>Fri, 06 May 2022 19:23:17 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/more_cpp14/</guid>
      <description>&lt;p&gt;C++14其实新增的特性不算太多，都是一些对C++11的一些优化和补充。大部分的新特性在前几篇文章&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/auto_enhanc&#34;&gt;《C++auto关键字改进》&lt;/a&gt;、&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/template_enhance&#34;&gt;《C++14模板的改进》&lt;/a&gt;、&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/read_write_lock&#34;&gt;《C++读写锁》&lt;/a&gt;、&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/exchange&#34;&gt;《C++14 exchange》&lt;/a&gt;中都有介绍，剩下的新特性在这篇文章中集中介绍。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;14 exchange</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/exchange/</link>
      <pubDate>Fri, 06 May 2022 15:18:41 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/exchange/</guid>
      <description>&lt;p&gt;C++14开始新增了&lt;code&gt;std::exchange&lt;/code&gt;函数，基于移动语义对资源进行转移，省去了拷贝的消耗。新增的这个函数名表面上看起来是“交换”，但实际上并不是两者进行交换，而是将后者转移给前者，后者没有变化。本节内容介绍&lt;code&gt;std::exchange&lt;/code&gt;和&lt;code&gt;std::swap&lt;/code&gt;实现上的区别。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;读写锁</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/read_write_lock/</link>
      <pubDate>Thu, 05 May 2022 14:33:59 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/read_write_lock/</guid>
      <description>&lt;p&gt;读写锁是并发编程中的一项重要的技术，相较于互斥锁（要么锁住要么不加锁），读写锁可以在更细的粒度上提高并发性能。现代C++提供了&lt;code&gt;std::shared_mutex&lt;/code&gt;和&lt;code&gt;std::shared_timed_mutex&lt;/code&gt;两种共享互斥量，以及用来管理这类共享互斥量的&lt;code&gt;std::shared_lock&lt;/code&gt;。本节内容对现代C++中的读写锁进行详细介绍。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;14模板的改进</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/template_enhance/</link>
      <pubDate>Thu, 05 May 2022 10:22:44 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/template_enhance/</guid>
      <description>&lt;p&gt;C++14引入了变量模板的新形式，在语法上等价于一个没有参数但是有返回值的模板函数。变量模板在语法上更加清晰简便，仅仅是一个语法糖。本节内容就介绍一下变量模板特性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;14 auto关键字的改进</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/auto_enhance/</link>
      <pubDate>Mon, 02 May 2022 16:17:28 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp14/auto_enhance/</guid>
      <description>&lt;p&gt;C++11对&lt;code&gt;auto&lt;/code&gt;关键字进行了重新定义，到了C++14又对&lt;code&gt;auto&lt;/code&gt;关键字做了进一步的改进。从&lt;code&gt;C++14&lt;/code&gt;开始，&lt;code&gt;auto&lt;/code&gt;关键字可以用于函数返回值推导和lambda表达式参数列表的类型推导了。本节内容就围绕这两项改进详细展开。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>STL std::sort是什么样的排序？</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/sort/</link>
      <pubDate>Fri, 29 Apr 2022 16:19:14 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/sort/</guid>
      <description>&lt;p&gt;排序是最基础的一种算法，C++的STL标准库也提供了一些关于排序算法的实现，其中使用最多的当属&lt;code&gt;std::sort()&lt;/code&gt;了，也是工作面试中的高频主角。本节内容将对&lt;code&gt;std::sort()&lt;/code&gt;具体的源码实现进行详细解剖。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL标准库概览</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/stl/</link>
      <pubDate>Thu, 28 Apr 2022 19:01:49 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/stl/</guid>
      <description>&lt;p&gt;STL的核心是三大组件：容器、迭代器和算法。本文通过一个概览图展示一下整个STL三大组件的逻辑关系。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;列表初始化</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/list_initialization/</link>
      <pubDate>Thu, 28 Apr 2022 15:05:41 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/list_initialization/</guid>
      <description>&lt;p&gt;在传统C++中，只能对普通数组和&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/pod&#34;&gt;POD类型&lt;/a&gt;使用列表初始化，适用范围非常有限。在现代C++中，统一了初始化方式，任何类型对象的初始化都可以使用列表初始化了。本节内容我们讲解列表初始化的各项使用细节。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; auto关键字</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/auto/</link>
      <pubDate>Thu, 28 Apr 2022 10:42:51 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/auto/</guid>
      <description>&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;关键字在C++11中进行了重新定义，抛弃了传统C++中&lt;code&gt;auto&lt;/code&gt;是用来自动延长对象生命周期的用法，而是将其用作类型自动推导。本节内容主要讨论&lt;code&gt;auto&lt;/code&gt;的用法以及一些注意事项。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;用户定义字面量</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/user_defined_literal/</link>
      <pubDate>Wed, 27 Apr 2022 17:09:25 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/user_defined_literal/</guid>
      <description>&lt;p&gt;C++11引入了用户自定义字面量（user-defined literal），也叫自定义后缀操作符。通过实现一个后缀操作符，可以将声明了后缀标识的字面量转换为所需的类型和数值。本节内容我们将探讨各种常见的字面量，以及C++11新加入的用户定义字面量。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;原始字符串字面量</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/raw_string_literal/</link>
      <pubDate>Wed, 27 Apr 2022 14:53:46 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/raw_string_literal/</guid>
      <description>&lt;p&gt;在传统C++中，字符串字面量的语法对一些特殊字符并不友好，需要通过转义字符来表示这些特殊字符。这对简单字符串计算量并不大，但在一些特殊情况如正则表达式中，可读性和性能就会非常差。因此C++11引入了原始字符串字面量（raw string literal）来解决字符串的表达形式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;类内初始化</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/in-class_initialization/</link>
      <pubDate>Wed, 27 Apr 2022 10:22:58 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/in-class_initialization/</guid>
      <description>&lt;p&gt;现代C++提供了3种对类成员的初始化方式，即构造函数初始化、初始化列表，以及C++11新加入的类内初始化。本节内容将具体讲解这3种类成员初始化方式的用法，并比较他们之间的区别。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;闭包</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/closure/</link>
      <pubDate>Tue, 26 Apr 2022 12:02:34 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/closure/</guid>
      <description>&lt;p&gt;闭包，closure，一般是指带有状态的函数，这里的状态指的是调用环境的上下文。一个函数带上了状态，就是闭包。那么闭包就需要有捕获并持有外部作用域变量的能力，闭包状态的捆绑发生在运行时。在C++中，闭包的实现方式包括仿函数、&lt;code&gt;std::bind()&lt;/code&gt;绑定器以及lambda表达式。仿函数在以前的文章&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/functor&#34;&gt;《C++仿函数》&lt;/a&gt;中以前介绍过了，本文将重点讨论另外两种闭包实现类型的用法和原理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;复制消除与RVO/NRVO</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/rvo_nrvo/</link>
      <pubDate>Mon, 25 Apr 2022 10:47:59 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/rvo_nrvo/</guid>
      <description>&lt;p&gt;C++11标准明确提出了复制消除（copy elision）优化技术，复制消除要求编译器在满足一些特定条件时，省略类对象的拷贝和移动构造，以达到优化效果。复制消除主要发生在两种条件下，即函数参数是值语义以及函数返回值是值语义。而RVO和NRVO是函数返回值优化的两种技术，NRVO从C++11开始加入C++标准。&lt;/p&gt;
&lt;p&gt;本文我们将讨论的主题围绕函数返回值优化，先了解RVO和NRVO在不同的现代C++版本中，启用和关闭编译器优化之后各自的表现；接着我们将分析RVO和NRVO的实现原理；最后聊一下优化失效的情形。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;引用包装</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/reference_wrapper/</link>
      <pubDate>Sun, 24 Apr 2022 19:32:40 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/reference_wrapper/</guid>
      <description>&lt;p&gt;现代C++引入一个&lt;code&gt;std::ref()&lt;/code&gt;用来模拟某个变量的引用。C++原来就有引用，为什么还需要模拟引用呢？这是为了解决某些场景下，只能值传递传参，却需要对传入的参数进行修改的问题。这类问题往往出现在函数式编程里。&lt;/p&gt;
&lt;p&gt;理解&lt;code&gt;std::ref()&lt;/code&gt;之前还需要先了解一个引用包装（reference wrapper）的概念，&lt;code&gt;std::ref()&lt;/code&gt;的返回值就是一个引用包装。&lt;/p&gt;
&lt;p&gt;本文围绕&lt;code&gt;&amp;lt;refwrap&amp;gt;&lt;/code&gt;头文件提供的&lt;code&gt;std::reference_wrapper&lt;/code&gt;和&lt;code&gt;std::ref&lt;/code&gt;的实现细节，来说明为什么需要这项技术。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;移动语义、万能引用、引用折叠、完美转发</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/move_forward/</link>
      <pubDate>Fri, 22 Apr 2022 19:10:23 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/move_forward/</guid>
      <description>&lt;p&gt;现代C++提供了移动语义相关的操作，通过移动语义可以将资源的所有权转移到新的对象上，从而避免数据拷贝带来的性能开销。移动语义实现了从一个对象到另一个对象的资源转移的过程。标准库为移动语义提供了辅助函数&lt;code&gt;std::move()&lt;/code&gt;，用于执行一个无条件的对&lt;code&gt;rvalue&lt;/code&gt;的转换，对于函数本身而言，并不移动任何内容，只是强制转化左值引用为右值引用，从而通过这个右值引用使用该值，以用于移动语义。与之类似的还有一个辅助函数&lt;code&gt;std::forward()&lt;/code&gt;，它和&lt;code&gt;std::move()&lt;/code&gt;类似，但只有在参数被一个&lt;code&gt;lvalue&lt;/code&gt;初始化时，才会转换为&lt;code&gt;rvalue&lt;/code&gt;。&lt;code&gt;std::forward()&lt;/code&gt;还能将一组参数原封不动地传递给另一个函数，包括参数的属性（左值/右值和&lt;code&gt;const&lt;/code&gt;/非&lt;code&gt;const&lt;/code&gt;），这个过程叫完美转发。&lt;/p&gt;
&lt;p&gt;提到移动语义和完美转发，就不得不谈及&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/lvalue_rvalue&#34;&gt;右值引用&lt;/a&gt;。右值引用的基本形式是&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;，这需要和模板编程中的万能引用&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;有所区别。在模板编程中，当传递不同属性的参数到&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;中时进行的类型推导需要遵循引用折叠原则。&lt;/p&gt;
&lt;p&gt;本节内容将就移动语义、万能引用、引用折叠和完美转发一一展开。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; NULL与nullptr</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/null_nullptr/</link>
      <pubDate>Fri, 22 Apr 2022 15:59:11 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/null_nullptr/</guid>
      <description>&lt;p&gt;在C语言中，我们使用&lt;code&gt;NULL&lt;/code&gt;来代表一个空指针，而这种做法在现代C++是不允许的。在现代C++中，&lt;code&gt;NULL&lt;/code&gt;本质上是一个类型为&lt;code&gt;long int&lt;/code&gt;的数值&lt;code&gt;0&lt;/code&gt;，而空指针需要用C++11新引入的&lt;code&gt;nullptr&lt;/code&gt;来表示。&lt;/p&gt;
&lt;p&gt;那么在现代C++中，&lt;code&gt;NULL&lt;/code&gt;和&lt;code&gt;nullptr&lt;/code&gt;使用上有什么区别？为什么会有&lt;code&gt;nullptr&lt;/code&gt;？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;智能指针</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/smart_pointer/</link>
      <pubDate>Tue, 19 Apr 2022 17:28:10 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp11/smart_pointer/</guid>
      <description>&lt;p&gt;在传统C++中，我们一般使用&lt;code&gt;new/delete&lt;/code&gt;或&lt;code&gt;malloc/free&lt;/code&gt;等方式来管理内存，但是由于申请内存和释放内存的过程都需要开发者自己维护，而只要是需要手动管理的逻辑，就有可能出现忘记释放或者多次释放内存的错误，这也是传统C++一致为人诟病的一个问题。在现代C++中，标准库提供了智能指针的实现，这些指针用于帮助确保程序不会出现内存和资源泄露，并具有异常安全。可以说现代C++的智能指针使得内存管理更加方便更加安全。本节内容我们将解析各类智能指针的底层实现原理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;内存对齐</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/memory_alignment/</link>
      <pubDate>Mon, 18 Apr 2022 11:55:22 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/memory_alignment/</guid>
      <description>&lt;p&gt;现代计算机的处理器为了高效地处理数据的存取，会以内存存取粒度为单位进行。为了让数据在内容中能够以内存存取粒度为单位进行排列，就需要内存对齐技术。本节内容将介绍内存对齐的意义和内存对齐规则。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;位域</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/bit_field/</link>
      <pubDate>Fri, 15 Apr 2022 21:22:55 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/bit_field/</guid>
      <description>&lt;p&gt;位域是一种特殊的数据结构，可以节省内存资源，使数据结构的存储更加紧凑。本节内容将全面了解一下位域的方方面面。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; RTTI与反射</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/rtti_reflection/</link>
      <pubDate>Fri, 15 Apr 2022 10:33:39 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/rtti_reflection/</guid>
      <description>&lt;p&gt;前文&lt;a href=&#34;https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_c++/language_base/object_memory_layout&#34;&gt;《对象内存模型》&lt;/a&gt;在介绍C++对象内存模型中有提到过&lt;code&gt;type_info&lt;/code&gt;对象。&lt;code&gt;type_info&lt;/code&gt;是RTTI机制的核心内容。那什么是RTTI？反射和RTTI又有什么关系？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;对象内存模型</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/object_memory_layout/</link>
      <pubDate>Tue, 12 Apr 2022 17:23:56 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/object_memory_layout/</guid>
      <description>&lt;p&gt;C++的三大特性是封装、继承和多态，而要理解这些特性的底层原理，就不得不说说C++对象的内存模型（布局）。&lt;/p&gt;
&lt;p&gt;对于一个C++对象，每个对象有独立的非静态数据成员，而内存中只有一份成员函数，所有该类的对象共享成员函数；&lt;code&gt;static&lt;/code&gt;数据成员属于类，它们存储在静态存储区，该类的所有对象共享。当调用对象的成员函数时，又是怎么识别是哪个对象在调用呢？实际上，所有类的成员函数在编译期会被编译器重构成非成员函数，即将&lt;code&gt;this&lt;/code&gt;指针作为函数的第一个参数，这样在函数中通过&lt;code&gt;this&lt;/code&gt;指针就能找到属于该对象的其他数据成员了。这些都是理解C++对象内存模型的前提。&lt;/p&gt;
&lt;p&gt;当出现了类的继承关系，且存在虚函数的时候，情况就复杂了。本节内容将详细介绍单一继承、多重继承、重复继承、虚拟继承等不同的继承方式的对象内存模型。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; extern关键字</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/extern/</link>
      <pubDate>Tue, 12 Apr 2022 14:21:09 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/extern/</guid>
      <description>&lt;p&gt;在C++标准库中，我们经常可以看到&lt;code&gt;extern&lt;/code&gt;关键字的使用。围绕声明与定义、&lt;code&gt;extern&lt;/code&gt;和&lt;code&gt;static&lt;/code&gt;、&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;，本节内容将尝试一次性讲清楚。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; volatile的作用</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/volatile/</link>
      <pubDate>Tue, 12 Apr 2022 10:19:28 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/volatile/</guid>
      <description>&lt;p&gt;C++中&lt;code&gt;volatile&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;对应，都是用来修饰变量的关键字。&lt;code&gt;volatile&lt;/code&gt;关键字通常用来建立语言级别的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C&#34;&gt;内存屏障（memory barrier）&lt;/a&gt;。为什么要使用&lt;code&gt;volatile&lt;/code&gt;？&lt;code&gt;volatile&lt;/code&gt;关键字的含义是什么？&lt;code&gt;volatile&lt;/code&gt;与多线程有什么关系？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;左值&amp;右值，左值引用&amp;右值引用</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/lvalue_rvalue/</link>
      <pubDate>Mon, 11 Apr 2022 16:22:51 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/lvalue_rvalue/</guid>
      <description>&lt;p&gt;C++11引入了右值引用的概念，用以区分C++11之前的引用（统称左值引用）。那么什么是右值引用？右值又是什么？和左值、左值引用有什么关系和区别？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; new表达式、operator new和placement new</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/new/</link>
      <pubDate>Mon, 11 Apr 2022 11:38:45 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/new/</guid>
      <description>&lt;p&gt;C++中&lt;code&gt;new&lt;/code&gt;关键字和&lt;code&gt;delete&lt;/code&gt;关键字我们肯定都使用过，它们是对堆中的内存进行申请和释放的操作，这两个操作是不能被重载的。有的同学可能会被问到，如何实现自定义内存分配行为。搞懂这个问题之前，我们需要先了解&lt;code&gt;new&lt;/code&gt;表达式、&lt;code&gt;operator new&lt;/code&gt;和&lt;code&gt;placement new&lt;/code&gt;之间的关系。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;仿函数</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/functor/</link>
      <pubDate>Sun, 10 Apr 2022 15:21:51 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/functor/</guid>
      <description>&lt;p&gt;C++中仿函数是一个能行使函数功能的类，仿函数的使用方法几乎和函数一样。那么仿函数和函数到底有什么区别？仿函数有哪些优点？本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;类型转换</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/type_cast/</link>
      <pubDate>Sun, 10 Apr 2022 11:28:51 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/type_cast/</guid>
      <description>&lt;p&gt;C++的类型转换分为隐式转换和显式转换。数值之间如何转换、指针之间如何转换、explicit关键字又是什么、强制类型转换操作符的区别又是什么，本节内容将一一解答。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;引用、指针、迭代器的区别？</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/reference_pointer_iterator/</link>
      <pubDate>Sun, 10 Apr 2022 10:26:35 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/reference_pointer_iterator/</guid>
      <description>&lt;p&gt;引用与指针的异同、指针与迭代器的异同，是一个老生常谈的话题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 什么是POD?</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/pod/</link>
      <pubDate>Sat, 09 Apr 2022 17:50:42 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/language_base/pod/</guid>
      <description>&lt;p&gt;为了兼容C内存的数据类型，C++11提出了POD的概念。什么是POD类型，POD类型有什么作用，本节内容将一一揭晓。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>应用技术</title>
      <link>https://zhxilin.github.io/post/tech_stack/9_application_technology/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:05:07 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/9_application_technology/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>软件工程</title>
      <link>https://zhxilin.github.io/post/tech_stack/8_software_engeering/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:04:53 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/8_software_engeering/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>分布式架构</title>
      <link>https://zhxilin.github.io/post/tech_stack/7_distributed_architecture/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:04:35 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/7_distributed_architecture/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>编译原理</title>
      <link>https://zhxilin.github.io/post/tech_stack/6_compile_principle/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:03:58 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/6_compile_principle/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数据库</title>
      <link>https://zhxilin.github.io/post/tech_stack/5_database/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:03:44 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/5_database/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>网络</title>
      <link>https://zhxilin.github.io/post/tech_stack/4_networks/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:03:37 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/4_networks/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://zhxilin.github.io/post/tech_stack/3_os/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:03:21 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/3_os/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数据结构与算法</title>
      <link>https://zhxilin.github.io/post/tech_stack/2_ds_algorithm/summary/</link>
      <pubDate>Fri, 08 Apr 2022 20:02:52 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/2_ds_algorithm/summary/</guid>
      <description></description>
    </item>
    
    <item>
      <title>编程语言</title>
      <link>https://zhxilin.github.io/post/tech_stack/1_programming_language/summary/</link>
      <pubDate>Fri, 08 Apr 2022 19:52:39 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/tech_stack/1_programming_language/summary/</guid>
      <description>&lt;p&gt;编程语言，是计算机科学的基础学科。C++作为一门历史悠久的常青树语言，也在不断与时俱进，注入新的活动，依然是当今最流行最稳定的编程语言之一。&lt;/p&gt;
&lt;p&gt;本章节将重点围绕现代C++、C++并发编程以及C++模板编程等方面展开。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SSL certificate and nginx config</title>
      <link>https://zhxilin.github.io/post/ssl_certificate_and_nginx_config/</link>
      <pubDate>Tue, 28 Sep 2021 14:03:54 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/ssl_certificate_and_nginx_config/</guid>
      <description>HTTP, as an application layer protocol, remains focused on presenting information, but cares less about the way this information travels from one place to another. Unfortunaly, this means that HTTP can be intercepted and potentially altered, making both the information and the information receiver vulnerable.
HTTPS protocol is an extension for HTTP. That &amp;ldquo;S&amp;rdquo; stands for Secure and it is powered by Transport Layer Secrurity(TLS), the succesor to Secure Sockets Layer(SSL).</description>
    </item>
    
    <item>
      <title>Solve Slow Access To Gitlab via ssh</title>
      <link>https://zhxilin.github.io/post/solve_slow_access_to_gitlab_via_ssh/</link>
      <pubDate>Wed, 08 Sep 2021 20:20:23 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/solve_slow_access_to_gitlab_via_ssh/</guid>
      <description>I&amp;rsquo;ve deployed a custom gitlab server for my team. I found that it&amp;rsquo;s weired that when clone, pull, push or fetch codes from the gitlab server via SSH, it performs slow response times for each access. But it works perfectly via HTTPS.
After seaching sort of posts, it&amp;rsquo;s pointed that the SSH service of gitlab server enables UseDNS feature by default, which makes it slow to access via SSH.
 While it is possible to run a GitLab instance using only IP addresses, it is often beneficial to use DNS as it is easier for users and is required for HTTPS.</description>
    </item>
    
    <item>
      <title>Update multiple versions of dev tools under Ubuntu</title>
      <link>https://zhxilin.github.io/post/ubuntu_update_alternatives/</link>
      <pubDate>Sun, 15 Aug 2021 15:12:30 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/ubuntu_update_alternatives/</guid>
      <description>Since different projects may require different versions of the same dev tool, we have to install multiple versions of them and provide a way for quick switch. This post introduces how to use update-alternatives command to switch dev tool versions under Ubuntu.
I will take protoc for example.
 ProjectA requires protoc 3.6.1 ProjectB requires protoc 3.17.0  Install multiple versions of protoc  Download different releases for Protocol Buffers  3.</description>
    </item>
    
    <item>
      <title>WSL2 Network Forwarding</title>
      <link>https://zhxilin.github.io/post/wsl2_network_forwarding/</link>
      <pubDate>Tue, 20 Jul 2021 10:21:46 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/wsl2_network_forwarding/</guid>
      <description>With the WSL2 Released, Microsoft has made a big change on the system architecture, including changing from the default bridged network adapter to a hyper-v virtual network adapter.
The new version of WSL is built on Hyper-V, which provides independent virtual network adapter for the virtual matchine. Therefore, WSL2 cannot share the network with host directly. The work around is to forward the TCP ports of WSL2 to the host OS.</description>
    </item>
    
    <item>
      <title>What&#39;s std::ios::sync_with_stdio(false) and std::cin.tie(nullptr)?</title>
      <link>https://zhxilin.github.io/post/sync_with_stdio_false_cin_tie_null/</link>
      <pubDate>Wed, 05 Aug 2020 10:45:18 +0800</pubDate>
      
      <guid>https://zhxilin.github.io/post/sync_with_stdio_false_cin_tie_null/</guid>
      <description>You may often see the following calls std::ios::sync_with_stdio(false) and std::cin.tie(nullptr) in some online judge system, such as leetcode, poj, etc. Someone would tell you that these codes are usually used to speed up the execution time. But what is the exact meanings for these codes?
1static auto _ = []() { 2 std::ios::sync_with_stdio(false); 3 std::cin.tie(nullptr); 4 return nullptr; 5}(); These two calls have different meanings that have nonthing to do with performance.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://zhxilin.github.io/about/</link>
      <pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zhxilin.github.io/about/</guid>
      <description>XILIN ZHENG (zhxilin)  Email: zhxilin@live.com Working: 8 years Education: Sun Yat-sen University (CS 2009-2013) Major: Software Engineering GitHub: https://github.com/zhxilin Blog: https://zhxilin.github.io  SKILLS  Game Server Dev: C++, C#, Golang, Python, NodeJS App Dev: UWP, WPF, Xamarin, Unity, Qt4(Basic) Database: Redis, MySQL Dev Tools: Vim, Git, VSCode Dev flow: Pull requests, Code review, Tests, Deploy IaaS: AliCloud, Google Cloud  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://zhxilin.github.io/archives/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhxilin.github.io/archives/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>